---
title: "Tess Assignment B-1"
date: "November 2, 2021"
output: 
  github_document:
    toc: true
    toc_depth: 4
    df_print: "default"
---

# Assignment B-1 

Welcome to my first assignment of **STAT545B**.

Below you will find a simple function I used a few times when making a script to produce relevant plots of my own data, the function is quite simple but I wanted to start with something I actually used in real life, and that was not too overwhelming!

#### First I will load all of the relevant packages I need 

--------------------------

```{r loading packages}
suppressPackageStartupMessages(library(datateachr))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(gapminder))
suppressPackageStartupMessages(library(testthat))
suppressPackageStartupMessages(library(dplyr))
```

### Exercise 1 and 2 

-------------------------------------

Now onto writing my function! I will first begin by documenting using roxygen2 format, then I will get into the actual function

```{r my function}

#' # Title
#' Mean and SD for your dataset
#' 
#' ## Description
#' This function will calculate the mean and standard deviation values for a variable of interest, specific to a group that you are interested in, the variable of interest must be numeric for this to work.
#' 
#' @param data the dataset you will want to run the mean and sd calculations on, named data as it is a clear descriptor of what this variable is doing in the function
#' @param group the group that you are interested in finding these values for, named group as it is a clear descriptor of what you should be entering in this function
#' @param col_x the specific value type you'd like to know these summary statistics for, while 'x' may have also been useful, this encourages the user to think more specifically about the column they will be entering, perhaps more helpful if you're new to code like me!
#'
#' @return return a tibble that includes the new data calculated as well as all the previous data, it differs from the summarise() function in dplyr this way
#'
#' @examples please see exercise 3.

mean_sd <- function(data, group, col_x) {
  calculation_check <- dplyr::summarise(data, 
                                        is_numeric_col = is.numeric({{ col_x }}),
                                        class_col = class({{ col_x }}))
  if (!(calculation_check$is_numeric_col)) {
    stop("The column selected is not numeric, it is: ", calculation_check$class_col)
  }
  calc_df <- data %>%
    group_by({{ group }}) %>%
    mutate(
      mean_value = mean({{ col_x }}),
      sd_value = sd({{ col_x }})
    )
  return(calc_df)
} 

mean_sd(gapminder, country, gdpPercap)
```
### Exercise 3 

-------------------------------------------

Below you will find some examples of data running in my function 

  * The first example includes some NAs and only a few repeat values (not every value being calculated has more than one member in it's group)
  
  * The second example shows a nice large grouping in the gapminder dataset
  
  * The third example demonstrates a resulting error that occurs if the user has inputted the incorrect data type using the gapminder dataset again

```{r Exercise 3: Examples, error = TRUE}
mtcars
#Example 1

df_1 <- data.frame(time = c(1, 1, 4, 3, 2, 3, 4, 5, NA, 6, 7),
                  value = c(0.3, 0.4, 0.9, 2, 8, 0.3, 0.6, NA, 0.7, 0.5, 0.3))

mean_sd(df_1, time, value)

#Example 2

mean_sd(gapminder, continent, pop)

#Example 3

mean_sd(gapminder, pop, continent)


```

As we can see, the function is working as expected, including to return an error. 
This is good news and means we should continue on to more formal means of testing! On to exercise 4. 

### Exercise 4 

-------------------------------------------

```{r, formal tests}

#Test 1
test_that("Checking errors function properly", {
  expect_error(mean_sd(mtcars, as.factor(cyl), as.factor(vs)), "The column selected is not numeric")
})

#Test 2, create a test dataframe for this one

df_2 <- gapminder %>%
  group_by(country) %>%
  mutate(
    mean_value = mean(lifeExp), 
    sd_value = sd(lifeExp)
  )

test_that("Output is correct", {
     expect_identical(mean_sd(gapminder, country, lifeExp), df_2)
  expect_s3_class(mean_sd(df_1, time, value), "tbl")
 })
```

Running the code chunk above should produce two passed tests, one indicating the function errors correctly, and one indicating that the correct type of output is being created in two non-redudant forms - one testing that manually running a similar code produces the expected output. Another that checks the type of output is a tibble, as expected. 


